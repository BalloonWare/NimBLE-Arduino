<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>esp-nimble-cpp / NimBLE-Arduino: Queue of Mbufs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">esp-nimble-cpp / NimBLE-Arduino
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___o_s_mqueue.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Queue of Mbufs<div class="ingroups"><a class="el" href="group___o_s_kernel.html">OSKernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga591927d5acaa98a8ab8c08c34c8585a7"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga591927d5acaa98a8ab8c08c34c8585a7">os_mqueue_get</a> (struct <a class="el" href="structos__mqueue.html">os_mqueue</a> *mq)</td></tr>
<tr class="separator:ga591927d5acaa98a8ab8c08c34c8585a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c63ba8e374531e0c02b3921a645cfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga85c63ba8e374531e0c02b3921a645cfd">os_mqueue_put</a> (struct <a class="el" href="structos__mqueue.html">os_mqueue</a> *mq, struct ble_npl_eventq *evq, struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *m)</td></tr>
<tr class="separator:ga85c63ba8e374531e0c02b3921a645cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc5f66105af5137ddb870e333c15af8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga7dc5f66105af5137ddb870e333c15af8">os_msys_register</a> (struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *new_pool)</td></tr>
<tr class="separator:ga7dc5f66105af5137ddb870e333c15af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa984a74000da6f436912a99821baeb9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#gaa984a74000da6f436912a99821baeb9a">os_msys_reset</a> (void)</td></tr>
<tr class="separator:gaa984a74000da6f436912a99821baeb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e887615518be2d1fc721815dfd157c5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga0e887615518be2d1fc721815dfd157c5">os_msys_get</a> (uint16_t dsize, uint16_t leadingspace)</td></tr>
<tr class="separator:ga0e887615518be2d1fc721815dfd157c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841e0b4f77115ec9df4b5becc252f03e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga841e0b4f77115ec9df4b5becc252f03e">os_msys_get_pkthdr</a> (uint16_t dsize, uint16_t user_hdr_len)</td></tr>
<tr class="separator:ga841e0b4f77115ec9df4b5becc252f03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82ba13b28a45ee54405dd7c4d6ea013b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga82ba13b28a45ee54405dd7c4d6ea013b">os_msys_count</a> (void)</td></tr>
<tr class="separator:ga82ba13b28a45ee54405dd7c4d6ea013b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2b97336a5ab02260a304188374d345"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#gadf2b97336a5ab02260a304188374d345">os_msys_num_free</a> (void)</td></tr>
<tr class="separator:gadf2b97336a5ab02260a304188374d345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b98d7358eaf82a9a842c667e588609"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#gaf9b98d7358eaf82a9a842c667e588609">os_mbuf_pool_init</a> (struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *omp, struct <a class="el" href="structos__mempool.html">os_mempool</a> *mp, uint16_t buf_len, uint16_t nbufs)</td></tr>
<tr class="separator:gaf9b98d7358eaf82a9a842c667e588609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae29f194bcb179147ab67901d8548e830"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#gae29f194bcb179147ab67901d8548e830">os_mbuf_get</a> (struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *omp, uint16_t leadingspace)</td></tr>
<tr class="separator:gae29f194bcb179147ab67901d8548e830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b6380071820bcbedb82843e5626f22e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga6b6380071820bcbedb82843e5626f22e">os_mbuf_get_pkthdr</a> (struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *omp, uint8_t user_pkthdr_len)</td></tr>
<tr class="separator:ga6b6380071820bcbedb82843e5626f22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga473f3f7a975c22725b35bf39f6ac633c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga473f3f7a975c22725b35bf39f6ac633c">os_mbuf_free</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om)</td></tr>
<tr class="separator:ga473f3f7a975c22725b35bf39f6ac633c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66de6a0a042c35435547a1df9534cc3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga66de6a0a042c35435547a1df9534cc3f">os_mbuf_free_chain</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om)</td></tr>
<tr class="separator:ga66de6a0a042c35435547a1df9534cc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1fae5a381d10a3697979e3952125223"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#gac1fae5a381d10a3697979e3952125223">os_mbuf_append</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, const void *data, uint16_t len)</td></tr>
<tr class="separator:gac1fae5a381d10a3697979e3952125223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66da7f4e54d6dbf4dc2d7531b68d7db0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga66da7f4e54d6dbf4dc2d7531b68d7db0">os_mbuf_appendfrom</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *dst, const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *src, uint16_t src_off, uint16_t len)</td></tr>
<tr class="separator:ga66da7f4e54d6dbf4dc2d7531b68d7db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69786be92f29171a54597afdb682ef2d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga69786be92f29171a54597afdb682ef2d">os_mbuf_dup</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om)</td></tr>
<tr class="separator:ga69786be92f29171a54597afdb682ef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd3dd2b8880a323c70478f8988902af"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#gabbd3dd2b8880a323c70478f8988902af">os_mbuf_off</a> (const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, int off, uint16_t *out_off)</td></tr>
<tr class="separator:gabbd3dd2b8880a323c70478f8988902af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1379ba25e8dc203a84ad6fc21f2880e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#gad1379ba25e8dc203a84ad6fc21f2880e">os_mbuf_adj</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *mp, int req_len)</td></tr>
<tr class="separator:gad1379ba25e8dc203a84ad6fc21f2880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d238e8abd1a459c2daf8fe814e13d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#gac5d238e8abd1a459c2daf8fe814e13d4">os_mbuf_cmpf</a> (const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, int off, const void *data, int len)</td></tr>
<tr class="separator:gac5d238e8abd1a459c2daf8fe814e13d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d6f4ce57b2c5c7b619831689f519f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga11d6f4ce57b2c5c7b619831689f519f1">os_mbuf_cmpm</a> (const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om1, uint16_t offset1, const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om2, uint16_t offset2, uint16_t len)</td></tr>
<tr class="separator:ga11d6f4ce57b2c5c7b619831689f519f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac16c27c68f35e4647823ae020411763f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#gac16c27c68f35e4647823ae020411763f">os_mbuf_prepend</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, int len)</td></tr>
<tr class="separator:gac16c27c68f35e4647823ae020411763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e76dec13d44abd6032eb293aa1b63a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#gac6e76dec13d44abd6032eb293aa1b63a">os_mbuf_prepend_pullup</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, uint16_t len)</td></tr>
<tr class="separator:gac6e76dec13d44abd6032eb293aa1b63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e87037857c05e8a9379bb2889947854"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga5e87037857c05e8a9379bb2889947854">os_mbuf_copyinto</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, int off, const void *src, int len)</td></tr>
<tr class="separator:ga5e87037857c05e8a9379bb2889947854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ab8ccc2730629ca0dd8c5190575213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga65ab8ccc2730629ca0dd8c5190575213">os_mbuf_concat</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *first, struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *second)</td></tr>
<tr class="separator:ga65ab8ccc2730629ca0dd8c5190575213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d81c50479c67444fd1a9449d4241ed"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga67d81c50479c67444fd1a9449d4241ed">os_mbuf_extend</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, uint16_t len)</td></tr>
<tr class="separator:ga67d81c50479c67444fd1a9449d4241ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3afad6750be6e7647ff0a19112ea36f7"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga3afad6750be6e7647ff0a19112ea36f7">os_mbuf_pullup</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om, uint16_t len)</td></tr>
<tr class="separator:ga3afad6750be6e7647ff0a19112ea36f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d87394f85361c8a72d7ec0f0416bd6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_mqueue.html#ga76d87394f85361c8a72d7ec0f0416bd6">os_mbuf_trim_front</a> (struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *om)</td></tr>
<tr class="separator:ga76d87394f85361c8a72d7ec0f0416bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad1379ba25e8dc203a84ad6fc21f2880e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_mbuf_adj </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>req_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adjust the length of a mbuf, trimming either from the head or the tail of the mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mbuf chain to adjust </td></tr>
    <tr><td class="paramname">req_len</td><td>The length to trim from the mbuf. If positive, trims from the head of the mbuf, if negative, trims from the tail of the mbuf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac1fae5a381d10a3697979e3952125223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append data onto a mbuf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The mbuf to append the data onto </td></tr>
    <tr><td class="paramname">data</td><td>The data to append onto the mbuf </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and an error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga66da7f4e54d6dbf4dc2d7531b68d7db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_appendfrom </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>src_off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data from one mbuf and appends it to another. On error, the specified data range may be partially appended. Neither mbuf is required to contain an mbuf packet header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The mbuf to append to. </td></tr>
    <tr><td class="paramname">src</td><td>The mbuf to copy data from. </td></tr>
    <tr><td class="paramname">src_off</td><td>The absolute offset within the source mbuf chain to read from. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; OS_EINVAL if the specified range extends beyond the end of the source mbuf chain. </dd></dl>

</div>
</div>
<a class="anchor" id="gac5d238e8abd1a459c2daf8fe814e13d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_cmpf </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a memory compare of the specified region of an mbuf chain against a flat buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The start of the mbuf chain to compare. </td></tr>
    <tr><td class="paramname">off</td><td>The offset within the mbuf chain to start the comparison. </td></tr>
    <tr><td class="paramname">data</td><td>The flat buffer to compare. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the flat buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both memory regions are identical; A memcmp return code if there is a mismatch; INT_MAX if the mbuf is too short. </dd></dl>

</div>
</div>
<a class="anchor" id="ga11d6f4ce57b2c5c7b619831689f519f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_cmpm </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the contents of two mbuf chains. The ranges of the two chains to be compared are specified via the two offset parameters and the len parameter. Neither mbuf chain is required to contain a packet header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om1</td><td>The first mbuf chain to compare. </td></tr>
    <tr><td class="paramname">offset1</td><td>The absolute offset within om1 at which to start the comparison. </td></tr>
    <tr><td class="paramname">om2</td><td>The second mbuf chain to compare. </td></tr>
    <tr><td class="paramname">offset2</td><td>The absolute offset within om2 at which to start the comparison. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if both mbuf segments are identical; A memcmp() return code if the segment contents differ; INT_MAX if a specified range extends beyond the end of its corresponding mbuf chain. </dd></dl>

</div>
</div>
<a class="anchor" id="ga65ab8ccc2730629ca0dd8c5190575213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_mbuf_concat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attaches a second mbuf chain onto the end of the first. If the first chain contains a packet header, the header's length is updated. If the second chain has a packet header, its header is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The mbuf chain being attached to. </td></tr>
    <tr><td class="paramname">second</td><td>The mbuf chain that gets attached. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5e87037857c05e8a9379bb2889947854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_copyinto </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the contents of a flat buffer into an mbuf chain, starting at the specified destination offset. If the mbuf is too small for the source data, it is extended as necessary. If the destination mbuf contains a packet header, the header length is updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to allocate from. </td></tr>
    <tr><td class="paramname">om</td><td>The mbuf chain to copy into. </td></tr>
    <tr><td class="paramname">off</td><td>The offset within the chain to copy to. </td></tr>
    <tr><td class="paramname">src</td><td>The source buffer to copy from. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; nonzero on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga69786be92f29171a54597afdb682ef2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_mbuf_dup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicate a chain of mbufs. Return the start of the duplicated chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to duplicate out of </td></tr>
    <tr><td class="paramname">om</td><td>The mbuf chain to duplicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new chain of mbufs </dd></dl>

</div>
</div>
<a class="anchor" id="ga67d81c50479c67444fd1a9449d4241ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* os_mbuf_extend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the length of an mbuf chain by the specified amount. If there is not sufficient room in the last buffer, a new buffer is allocated and appended to the chain. It is an error to request more data than can fit in a single buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td></td></tr>
    <tr><td class="paramname">om</td><td>The head of the chain to extend. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to extend by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new data on success; NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga473f3f7a975c22725b35bf39f6ac633c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a mbuf back to the pool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The Mbuf pool to release back to </td></tr>
    <tr><td class="paramname">om</td><td>The Mbuf to release back to the pool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga66de6a0a042c35435547a1df9534cc3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_free_chain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a chain of mbufs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to free the chain of mbufs into </td></tr>
    <tr><td class="paramname">om</td><td>The starting mbuf of the chain to free back into the pool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gae29f194bcb179147ab67901d8548e830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_mbuf_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *&#160;</td>
          <td class="paramname"><em>omp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an mbuf from the mbuf pool. The mbuf is allocated, and initialized prior to being returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to return the packet from </td></tr>
    <tr><td class="paramname">leadingspace</td><td>The amount of leadingspace to put before the data section by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An initialized mbuf on success, and NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b6380071820bcbedb82843e5626f22e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_mbuf_get_pkthdr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *&#160;</td>
          <td class="paramname"><em>omp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pkthdr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new packet header mbuf out of the <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to allocate out of </td></tr>
    <tr><td class="paramname">user_pkthdr_len</td><td>The packet header length to reserve for the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A freshly allocated mbuf on success, NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbd3dd2b8880a323c70478f8988902af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_mbuf_off </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>out_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locates the specified absolute offset within an mbuf chain. The offset can be one past than the total length of the chain, but no greater.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The start of the mbuf chain to seek within. </td></tr>
    <tr><td class="paramname">off</td><td>The absolute address to find. </td></tr>
    <tr><td class="paramname">out_off</td><td>On success, this points to the relative offset within the returned mbuf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mbuf containing the specified offset on success. NULL if the specified offset is out of bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9b98d7358eaf82a9a842c667e588609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mbuf_pool_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structos__mempool.html">os_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a pool of mbufs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to initialize </td></tr>
    <tr><td class="paramname">mp</td><td>The memory pool that will hold this mbuf pool </td></tr>
    <tr><td class="paramname">buf_len</td><td>The length of the buffer itself. </td></tr>
    <tr><td class="paramname">nbufs</td><td>The number of buffers in the pool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gac16c27c68f35e4647823ae020411763f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_mbuf_prepend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the length of an mbuf chain by adding data to the front. If there is insufficient room in the leading mbuf, additional mbufs are allocated and prepended as necessary. If this function fails to allocate an mbuf, the entire chain is freed.</p>
<p>The specified mbuf chain does not need to contain a packet header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to allocate from. </td></tr>
    <tr><td class="paramname">om</td><td>The head of the mbuf chain. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to prepend.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new head of the chain on success; NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gac6e76dec13d44abd6032eb293aa1b63a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_mbuf_prepend_pullup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepends a chunk of empty data to the specified mbuf chain and ensures the chunk is contiguous. If either operation fails, the specified mbuf chain is freed and NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The mbuf chain to prepend to. </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes to prepend and pullup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified mbuf on success; NULL on failure (and the mbuf chain is freed). </dd></dl>

</div>
</div>
<a class="anchor" id="ga3afad6750be6e7647ff0a19112ea36f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_mbuf_pullup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rearrange a mbuf chain so that len bytes are contiguous, and in the data area of an mbuf (so that <a class="el" href="group___o_s_mbuf.html#ga4bf84d7b323b20131da17c8bfed65674">OS_MBUF_DATA()</a> will work on a structure of size len.) Returns the resulting mbuf chain on success, free's it and returns NULL on failure.</p>
<p>If there is room, it will add up to "max_protohdr - len" extra bytes to the contiguous region, in an attempt to avoid being called next time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">omp</td><td>The mbuf pool to take the mbufs out of </td></tr>
    <tr><td class="paramname">om</td><td>The mbuf chain to make contiguous </td></tr>
    <tr><td class="paramname">len</td><td>The number of bytes in the chain to make contiguous</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contiguous mbuf chain on success, NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga76d87394f85361c8a72d7ec0f0416bd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_mbuf_trim_front </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname"><em>om</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes and frees empty mbufs from the front of a chain. If the chain contains a packet header, it is preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">om</td><td>The mbuf chain to trim.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The head of the trimmed mbuf chain. </dd></dl>

</div>
</div>
<a class="anchor" id="ga591927d5acaa98a8ab8c08c34c8585a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_mqueue_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mqueue.html">os_mqueue</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove and return a single mbuf from the mbuf queue. Does not block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>The mbuf queue to pull an element off of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next mbuf in the queue, or NULL if queue has no mbufs. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85c63ba8e374531e0c02b3921a645cfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_mqueue_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mqueue.html">os_mqueue</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ble_npl_eventq *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf.html">os_mbuf</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a packet (i.e. packet header mbuf) to an mqueue. The event associated with the mqueue gets posted to the specified eventq.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq</td><td>The mbuf queue to append the mbuf to. </td></tr>
    <tr><td class="paramname">evq</td><td>The event queue to post an event to. </td></tr>
    <tr><td class="paramname">m</td><td>The mbuf to append to the mbuf queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga82ba13b28a45ee54405dd7c4d6ea013b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_msys_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the number of blocks in all the mbuf pools that are allocated.</p>
<dl class="section return"><dt>Returns</dt><dd>total number of blocks allocated in Msys </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e887615518be2d1fc721815dfd157c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_msys_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>leadingspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a mbuf from msys. Based upon the data size requested, <a class="el" href="group___o_s_mbuf.html#ga0e887615518be2d1fc721815dfd157c5">os_msys_get()</a> will choose the mbuf pool that has the best fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dsize</td><td>The estimated size of the data being stored in the mbuf </td></tr>
    <tr><td class="paramname">leadingspace</td><td>The amount of leadingspace to allocate in the mbuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A freshly allocated mbuf on success, NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga841e0b4f77115ec9df4b5becc252f03e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structos__mbuf.html">os_mbuf</a>* os_msys_get_pkthdr </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>user_hdr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a packet header structure from the MSYS pool. See <a class="el" href="group___o_s_mbuf.html#ga164e3f90cdee2692a85c249761ba001e">os_msys_register()</a> for a description of MSYS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dsize</td><td>The estimated size of the data being stored in the mbuf </td></tr>
    <tr><td class="paramname">user_hdr_len</td><td>The length to allocate for the packet header structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A freshly allocated mbuf on success, NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf2b97336a5ab02260a304188374d345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_msys_num_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of free blocks in Msys</p>
<dl class="section return"><dt>Returns</dt><dd>Number of free blocks available in Msys </dd></dl>

</div>
</div>
<a class="anchor" id="ga7dc5f66105af5137ddb870e333c15af8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int os_msys_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structos__mbuf__pool.html">os_mbuf_pool</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MSYS is a system level mbuf registry. Allows the system to share packet buffers amongst the various networking stacks that can be running simultaeneously.</p>
<p>Mbuf pools are created in the system initialization code, and then when a mbuf is allocated out of msys, it will try and find the best fit based upon estimated mbuf size.</p>
<p><a class="el" href="group___o_s_mbuf.html#ga164e3f90cdee2692a85c249761ba001e">os_msys_register()</a> registers a mbuf pool with MSYS, and allows MSYS to allocate mbufs out of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_pool</td><td>The pool to register with MSYS</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaa984a74000da6f436912a99821baeb9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void os_msys_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-registers all mbuf pools from msys. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
